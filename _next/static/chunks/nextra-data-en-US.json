{"/":{"title":"Introduction","data":{"":"안녕하세요. 이 블로그는 Spring Webflux 기반의 Spring Security 관련된 예제와 개념, 문서를 정리하는 곳입니다. 간단한 JWT 인증을 ReactiveAuthenticationManager 를 이용해서 구현하는 것부터 시작해서 OAuth2 까지 정리해둘 예정입니다.이 외에도 Servlet 기반의 간단한 JWT 인증 예제 역시 정리해 둘 예정입니다.\nhttps://github.com/chagchagchag/webflux-mongo-mysql-redis/tree/main/foobar-user\nhttps://github.com/chagchagchag/example-oauth2-client"}},"/jwt-authentication-manager-way/example-using-reactive-authentication-manager":{"title":"Example Using Reactive Authentication Manager","data":{"reactiveauthenticationmanager-기반의-인증#ReactiveAuthenticationManager 기반의 인증":"스프링 시큐리티 관련 개념을 문서를 정리할 때마다 항상 고통스럽고 설명이 쉽지 않았었는데요. 최대한 쉽게 융통성 있게 설명해보겠습니다.이번 글에서는 SecurityConfig 를 필터체인을 Bean 으로 등록하는 방식을 설명합니다.  WebSecurityConfgiurerAdapter 를 상속해서 configure 메서드를 오버라이딩 하던 2.7.x 버전대의 시큐리티 코드 작성 방식은 이 글에서 다루지 않기로 했습니다. 저 역시도 이 방식을 본지가 꽤 오래되어서 기억이 안나기도 하고 지금와서 다시 예제를 하나 더 추가하기에는 시간도 부족해서 다루지 않기로 했습니다.예제의 내용은 id/pw 기반으로 인증을 하고 있는 단순한 내용입니다.\r\nemail/password 기반으로 할까 하다가 예제가 산만해질것 같아서 id/pw 기반의 예제를 작성하는 것으로 결정했습니다.","코드#코드":"모든 코드는 https://github.com/chagchagchag/webflux-mongo-mysql-redis/tree/main/foobar-user 에 있는 코드입니다.","의존성#의존성":"jwt 인증을 사용할 것이기에 jwt 인증과 security 의존성을 추가했습니다.\ndependencies{\r\n    // ...\r\n    \r\n    // security\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-security\")\r\n\r\n\t// jwt\r\n\timplementation(\"io.jsonwebtoken:jjwt-api:0.11.2\")\r\n\timplementation(\"io.jsonwebtoken:jjwt-impl:0.11.2\")\r\n\timplementation(\"io.jsonwebtoken:jjwt-jackson:0.11.2\")\r\n    \r\n    // ...\r\n}","securityconfigjava#SecurityConfig.java":"먼저 아래와 같은 SecurityConfig 클래스를 작성합니다. SecurityConfig 클래스 코드를 먼저 보는 이유는 어떤 기능을 추가할지 명확하게 보여주기 때문에 SecurityConfig 코드를 먼저 추가했습니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@EnableWebFluxSecurity // (0)\r\n@Configuration // (0)\r\npublic class SecurityConfig {\r\n\r\n  @Bean\r\n  public SecurityWebFilterChain filterChain(\r\n      ServerHttpSecurity httpSecurity,\r\n      JwtServerAuthenticationConverter converter, // (1)\r\n      JwtAuthenticationManager authenticationManager // (1)\r\n  ){\r\n    // (1)\r\n    var authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);\r\n    authenticationWebFilter.setServerAuthenticationConverter(converter); // (1)\r\n\r\n    // (2)\r\n    return httpSecurity\r\n        // (3)\r\n        .exceptionHandling(exceptionHandlingSpec ->\r\n            exceptionHandlingSpec.authenticationEntryPoint(\r\n                (exchange, ex) -> Mono.fromRunnable(() -> {\r\n                  exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\r\n                  exchange.getResponse().getHeaders().set(HttpHeaders.WWW_AUTHENTICATE, \"Bearer\");\r\n                })\r\n            )\r\n        )\r\n        .csrf(csrfSpec -> csrfSpec.disable()) // (4)\r\n        .formLogin(formLoginSpec -> formLoginSpec.disable()) // (4)\r\n        .httpBasic(httpBasicSpec -> httpBasicSpec.disable()) // (4)\r\n        // (5)\r\n        .authorizeExchange(authorizeExchangeSpec ->\r\n            authorizeExchangeSpec\r\n                .pathMatchers(\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\")\r\n                .permitAll()\r\n                .pathMatchers(\"/swagger-ui.html\", \"/webjars/**\")\r\n                .permitAll()\r\n                .pathMatchers(\"/healthcheck/ready\")\r\n                .permitAll()\r\n                .pathMatchers(\"/api/users/login\", \"/api/users/signup\")\r\n                .permitAll()\r\n                .pathMatchers(\"/logout\", \"/api/users/profile/**\")\r\n                .hasAnyAuthority(\"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\")\r\n        )\r\n        // (6)\r\n        .headers(headerSpec -> headerSpec.frameOptions(frameOptionsSpec -> frameOptionsSpec.disable()))\r\n        // (7)\r\n        .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION)\r\n        .build();\r\n  }\r\n}\n(0)\n@RequiredArgsConstructor\r\n@EnableWebFluxSecurity // (0)\r\n@Configuration // (0)\r\npublic class SecurityConfig {\r\n    // ...\r\n}\n@EnableWebFluxSecurity, @Configuration 을 추가해줍니다. @EnableWebFluxSecurity 는 ServerHttpSecurityConfiguration.class, WebFluxSecurityConfiguration.class, ReactiveOAuth2ClientImportSelector.class 설정을 포함하는 설정입니다.\n(1)AuthenticationWebFilter 객체를 생성합니다. 그리고 이 AuthenticationWebFilter 객체에는 직접 커스텀하게 구현해둔 JwtAuthenticationManager 객체를 바인딩해줍니다. 위의 코드에서는 AuthenticationWebFilter 생성자에 JwtAuthenticationManager 객체를 바인딩해줬습니다.직접 작성한 클래스인 JwtAuthenticationManager 클래스의 내용은 이글의 하단부에 설명 예정입니다.\n(2) HttpSecurity httpSecurityHttpSecurity httpSecurity  빈을 주입받은 후 httpSecurity객체의 build() 함수를 이용해서 SecurityWebFilterChain을 빈으로 등록합니다.\n(3)\nhttpSecurity\r\n// (3)\r\n.exceptionHandling(exceptionHandlingSpec ->\r\n    exceptionHandlingSpec.authenticationEntryPoint(\r\n        (exchange, ex) -> Mono.fromRunnable(() -> {\r\n          exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // (i)\r\n          exchange.getResponse().getHeaders().set(HttpHeaders.WWW_AUTHENTICATE, \"Bearer\"); // (ii)\r\n        })\r\n    )\r\n)\n(i)\n인증이 실패했을 때 StatusCode 를 어떤 것으로 내려줄지를 정의합니다.\n(ii)\nResponse 헤더에는 { WWW-Authenticate : Bearer }을 지정해주었습니다.\n(4)\nhttpSecurity\r\n// ...\r\n// (3)\r\n.csrf(csrfSpec -> csrfSpec.disable()) // (i)\r\n.formLogin(formLoginSpec -> formLoginSpec.disable()) // (ii)\r\n.httpBasic(httpBasicSpec -> httpBasicSpec.disable()) // (iii)\r\n// ...\n(i) : csrf를 비활성화합니다. (ii) : formLogin 을 비활성화 합니다.(iii) : httpBasic 역시 비활성화 합니다.\n(5)\nhttp\r\n// ...\r\n// (5)\r\n.authorizeExchange(authorizeExchangeSpec ->\r\n    authorizeExchangeSpec\r\n        // (i)\r\n        .pathMatchers(\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\")\r\n        .permitAll()\r\n        // (ii)\r\n        .pathMatchers(\"/swagger-ui.html\", \"/webjars/**\")\r\n        .permitAll()\r\n        // (iii)\r\n        .pathMatchers(\"/healthcheck/ready\")\r\n        .permitAll()\r\n        // (iv)\r\n        .pathMatchers(\"/api/users/login\", \"/api/users/signup\")\r\n        .permitAll()\r\n        // (v)\r\n        .pathMatchers(\"/logout\", \"/api/users/profile/**\")\r\n        .hasAnyAuthority(\"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\")\r\n)\n(i), (ii), (iii), (iv)\n\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\" 에 대해서는 permitAll 해줍니다.\n\"/swagger-ui.html\", \"/webjars/**\" 에 대해서 permitAll 해줍니다.\n\"/healthcheck/ready\" 에 대해서도 permitAll 해줍니다.\n\"/api/users/login\", \"/api/users/signup\" 에 대해서도 역시 permitAll 해줍니다.\n(v)\n\"/logout\", \"/api/users/profile/**\" 에 대해서는 \"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\" 의 권한에 대해서만 허용합니다.\n(6)X-Frame-Options 헤더를 적용합니다. X-Frame-Options는 웹 페이지를 <frame>, <iframe>, <embed>, <object>와 같은 태그를 사용하여 다른 웹 사이트에 삽입되는 것을 방지하는 데 사용합니다. 궁금하시다면 Chat GPT에게 Spring security 에서 headerSpec.frameOptions 는 무슨 기능을 해? 라고 질문해보시기 바랍니다.\nhttp\r\n// ...\r\n// (6)\r\n.headers(headerSpec -> headerSpec.frameOptions(frameOptionsSpec -> frameOptionsSpec.disable()))\r\n// ...\n(7)위에서 생성해둔 authenticationWebFilter 를 httpSecurity 객체에 추가해 준 후 HttpSecurity 의 build() 메서드를 통해 SecurityWebFilterChain 객체를 생성합니다.\nhttp\r\n// ...\r\n// (7)\r\n.addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION)\r\n.build();","jwtauthenticationmanager#JwtAuthenticationManager":"직접 작성한 JwtAuthenticationManager 클래스는 ReactiveAuthenticationManager 를 implements 해서 직접 작성한 클래스입니다. 이 글의 하단 부에 AuthenticationManager, AuthenticationManagerBuilder, HttpSecurity, AuthenticationManagerProvider 가 어떻게 상호작용하는지를 설명합니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // (1)\r\n  private final JwtSupport jwtSupport; // (1)\r\n  private final CustomUserDetailsService userDetailsService; // (1)\r\n\r\n  // (2)\r\n  @Override\r\n  public Mono<Authentication> authenticate(Authentication authentication) {\r\n    return Mono.justOrEmpty(authentication)\r\n        .filter(auth -> auth instanceof BearerToken)\r\n        .cast(BearerToken.class)\r\n        .map(bearerToken -> degenerateToken(bearerToken))\r\n        .flatMap(jwtDto -> validateJwt(jwtDto))\r\n        .flatMap(jwtDto -> findUserById(jwtDto.id()))\r\n        .onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\r\n  }\r\n\r\n  // (3) 간단한 설명이기에 설명은 생략\r\n  public JwtDto degenerateToken(BearerToken token){\r\n    return jwtSupport.degenerateToken(SecurityProperties.key, token.getJwt());\r\n  }\r\n\r\n  // (4) 간단한 내용이기에 설명은 생략\r\n  public Mono<JwtDto> validateJwt(JwtDto jwtDto){\r\n    if(jwtSupport.checkIfNotExpired(jwtDto.expiration())){\r\n      return Mono.just(jwtDto);\r\n    }\r\n    return Mono.error(new IllegalArgumentException(\"Token Invalid\"));\r\n  }\r\n\r\n  // (5)\r\n  private Mono<Authentication> findUserById(String userId){\r\n    return userDetailsService\r\n        .findByUsername(userId)\r\n        .map(userDetails -> {\r\n          var authentication = new UsernamePasswordAuthenticationToken(\r\n              userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities()\r\n          );\r\n          SecurityContextHolder.getContext().setAuthentication(authentication);\r\n          return authentication;\r\n        });\r\n  }\r\n  \r\n}\n(1)\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // (1)\r\n  private final JwtSupport jwtSupport; // (1)\r\n  private final CustomUserDetailsService userDetailsService; // (1)\r\n    \r\n  // ...\r\n}\nJwtSupport 는 직접 정의했던 JwtSupport 클래스입니다. 자세한 내용은 JWT 생성, 분해 예제 에 정리해두었습니다.\nCustomUserDetailsService 를 바인딩해줬습니다. CustomUserDetailsService 에 대한 내용은 이글의 하단에 추가해두었습니다.\n(2)ReactiveAuthenticationManager interface의 authenticate(Authentication authentication) 을 override 하는 예제입니다.\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // ...\r\n  // (2)\r\n  @Override\r\n  public Mono<Authentication> authenticate(Authentication authentication) {\r\n    return Mono.justOrEmpty(authentication)\r\n        .filter(auth -> auth instanceof BearerToken)\r\n        .cast(BearerToken.class)\r\n        .map(bearerToken -> degenerateToken(bearerToken))\r\n        .flatMap(jwtDto -> validateJwt(jwtDto))\r\n        .flatMap(jwtDto -> findUserById(jwtDto.id()))\r\n        .onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\r\n  }\r\n  // ...\r\n}\n.filter(auth -> auth instanceof BearerToken)\nBearerToken 객체 타입인지 검사합니다. BearerToken 은 직접 정의한 객체입니다. 이 문서의 하단에 설명을 추가해두었습니다.\n.cast(BearerToken.class)\n현재 필터에 들어온 Authentication 객체를 BearerToken 타입으로 변환해줍니다.\n.map(bearerToken -> degenerateToken(bearerToken))\nbearerToken 이라는 이름의 Authentication 객체를 JwtDto 로 변환해줍니다.\ndegenerateToken(Authentication) 메서드는 (3) 에서 설명합니다.\n.flatMap(jwtDto -> validateJwt(jwtDto))\nvalidateJwt(jwtDto)에 대해서 변환되어진 jwtDto 에 대해서 Jwt 가 expiration 이 만료되었는지를 검사합니다.\n.flatMap(jwtDto -> findUserById(jwtDto.id()))\nvalidation 이 끝난 JwtDto 객체에 대해서 findUserById(...) 메서드를 통해서 실제 Database에 저장된 사용자인지를 검증합니다.\n.onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\n에러가 났을 때는 어떤 Exception 을 낼지 정의합니다.\n(5)\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // ...\r\n  \r\n  // (5)\r\n  private Mono<Authentication> findUserById(String userId){\r\n    return userDetailsService\r\n        .findByUsername(userId)\r\n        .map(userDetails -> {\r\n          var authentication = new UsernamePasswordAuthenticationToken(\r\n              userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities()\r\n          );\r\n          SecurityContextHolder.getContext().setAuthentication(authentication);\r\n          return authentication;\r\n        });\r\n  }\r\n    \r\n  // ...\r\n}\nUserDetailsService 에서 findByUsername(userId) 를 통해서 userId에 대해서 사용자가 존재하는지 조회합니다. 조회 결과로 찾아낸 사용자에 대해서 Authentication 객체인 UsernamePasswordAuthenticationToken 으로 생성하고 이 객체를 SecurityContextHolder 에 Authentication 객체를 저장합니다.그리고 새롭게 업데이트 된 Authentication 객체를 return 하는 것으로 메서드의 실행을 마무리합니다.","jwtserverauthenticationconverter#JwtServerAuthenticationConverter":"이 JwtServerAuthenticationConverter 는 위의 SecurityConfig 코드 내에서 등록할 때에는 var authenticationWebFilter = new AuthenticationWebFilter(authenticationManager); 을 통해 생성한 AuthenticationWebFilter 객체에 대해 authenticationWebFilter.setServerAuthenticationConverter(converter); 코드를 통해서 컨버터를 등록합니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\nimport io.chagchagchag.example.foobar.dataaccess.user.security.BearerToken;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.web.server.authentication.ServerAuthenticationConverter;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtServerAuthenticationConverter implements ServerAuthenticationConverter {\r\n\r\n  @Override\r\n  public Mono<Authentication> convert(ServerWebExchange exchange) {\r\n    return Mono.justOrEmpty(exchange.getRequest())\r\n        .flatMap(serverHttpRequest -> Mono.justOrEmpty(serverHttpRequest.getHeaders()))\r\n        .flatMap(httpHeaders -> Mono.justOrEmpty(httpHeaders.getFirst(HttpHeaders.AUTHORIZATION)))\r\n        .filter(headerValue -> checkContainsBearer(headerValue))\r\n        .flatMap(jwt -> Mono.justOrEmpty(new BearerToken(jwt)));\r\n  }\r\n\r\n  public Boolean checkContainsBearer(String header){\r\n    var len = \"Bearer \".length();\r\n    return header.substring(0, len).equalsIgnoreCase(\"Bearer\");\r\n  }\r\n\r\n}\r\nconvert() 함수의 내용이 길어보이지만 serverHttpRequest.getHeaders().getFirst(HttpHeaders.AUTHORIZATION) 으로 얻은 String 내에 Bearer 문자열이 있는지를 검사하는 코드입니다. Null 체크를 해야 하기에 null 이 생길수 있는 부분들을 각각 Mono.flatMap 과 Mono.justOrEmpty() 로 분리해서 연결했습니다.","bearertoken#BearerToken":"위의 코드에서 사용한 BearerToken 은 아래와 같습니다. AbstractAuthenticationToken 객체를 상속한 클래스이고 SecurityFilterChain 에 등록된 필터가 검사할때는 Authentication 객체를 통해 검사를 수행하게 됩니다. (AbstractAuthenticationToken 객체는 Authentication 인터페이스를 implements 한 클래스입니다.)\npackage io.chagchagchag.example.foobar.dataaccess.user.security;\r\n\r\nimport lombok.Getter;\r\nimport org.springframework.security.authentication.AbstractAuthenticationToken;\r\nimport org.springframework.security.core.authority.AuthorityUtils;\r\n\r\n@Getter\r\npublic class BearerToken extends AbstractAuthenticationToken {\r\n  private final String jwt;\r\n  public BearerToken(String jwt){\r\n    super(AuthorityUtils.NO_AUTHORITIES);\r\n    this.jwt = jwt;\r\n  }\r\n\r\n  @Override\r\n  public Object getCredentials() {\r\n    return jwt;\r\n  }\r\n\r\n  @Override\r\n  public Object getPrincipal() {\r\n    return jwt;\r\n  }\r\n}","customuserdetailsservice#CustomUserDetailsService":"package io.chagchagchag.example.foobar.user.config.security;\r\n\r\nimport io.chagchagchag.example.foobar.dataaccess.user.repository.UserR2dbcRepository;\r\nimport io.chagchagchag.example.foobar.dataaccess.user.security.UserDetailsMapper;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.security.core.userdetails.ReactiveUserDetailsService;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.stereotype.Component;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class CustomUserDetailsService implements ReactiveUserDetailsService {\r\n  private final UserR2dbcRepository userR2dbcRepository;\r\n  private final UserDetailsMapper userDetailsMapper;\r\n\r\n  // id 가 존재하는지만 검사하고, 이것을 UserDetails 로 반환한다.\r\n  @Override\r\n  public Mono<UserDetails> findByUsername(String userId) {\r\n    return userR2dbcRepository\r\n        .findById(Long.parseLong(userId))\r\n        .map(userEntity -> userDetailsMapper.defaultUserDetails(userEntity));\r\n  }\r\n\r\n}","userdetailsmapper#UserDetailsMapper":"UserDetailsMapper 내의 defaultUserDetails 메서드는 아래와 같이 정의해두었습니다.\n// ...\r\n\r\nimport org.springframework.security.core.userdetails.User;\r\n// ...\r\n\r\n@Component\r\npublic class UserDetailsMapper {\r\n  public User defaultUserDetails(UserEntity userEntity){\r\n    return new User(\r\n        String.valueOf(userEntity.getId()),\r\n        userEntity.getPassword(),\r\n        true, true, true, true,\r\n        new ArrayList<GrantedAuthority>()\r\n    );\r\n  }\r\n}"}},"/oauth2/google-cloud-platform":{"title":"Google Cloud Platform","data":{"구글-클라우드-앱-토큰-생성#구글 클라우드 앱 토큰 생성":"주의\n앱 이름에는 'google' 이라는 단어가 들어가면 안됩니다.앱 이름에 'google' 이라는 단어가 포함되면 에러를 내기에 아래 예제문서에서는 'analytics-manager' 라는 이름으로 지정해주었습니다.\n참고 : 앱을 저장하는 중에 오류가 발생했습니다. 요청이 악용으로 분류되었으며 진행할 수 없습니다. 해결 방법\n이번 설명 문서에서는 프로젝트 명에 'google' 이라는 단어를 포함했지만, 나중에 혼동을 방지하고 싶다면 가급적이면 프로젝트 명도 'google' 단어를 포함하지 않는 것을 추천합니다.\nhttps://cloud.google.com/?hl=ko 에 접속합니다.\n로그인하면 아래와 같은 팝업이 나타납니다. (또는 무료로 시작하기 버튼을 누르면 아래 팝업이 페이지로 나타납니다.)\n프로젝트 선택 → 새 프로젝트\n프로젝트 명을 입력합니다. 그리고 만들기 버튼을 클릭하세요.\n방금 만든 google-analytics-manager  프로젝트를 선택합니다.\nAPI 및 서비스 → 사용자 인증 정보 를 클릭합니다.\n동의화면 구성 버튼을 클릭합니다.\nUserType 은 \"외부\"를 선택해서 만들기를 클릭합니다.\n앱 이름에는 google 이라는 단어가 들어가면 안됩니다.google 이라는 단어가 포함되면 에러를 내기에 아래와 같이 analytics-manager 라는 이름으로 지정해주었습니다.\n참고 : 앱을 저장하는 중에 오류가 발생했습니다. 요청이 악용으로 분류되었으며 진행할 수 없습니다. 해결 방법\n범위 추가 또는 삭제 버튼을 클릭합니다.\n스코프를 선택합니다. 가장 최소한도의 범위인 email, openid 만 선택했습니다. 그리고 업데이트 버튼을 클릭합니다.\n선택한 내용을 확인하는 화면인데, \"저장 후 계속\" 버튼을 클릭해서 다음 페이지로 이동합니다.\n테스트 사용자 화면입니다. 아직 테스트 사용자를 추가하지 않을 것이기에 아무것도 하지 않고 \"저장 후 계속\" 을 클릭합니다.\nOAuth 동의화면이 나타납니다.\n사용자 인증 정보 → 사용자 인증 정보 만들기 → OAuth 클라이언트 ID 를 선택합니다.\n아래와 같이 선택하고 '만들기'버튼을 클릭하시면 됩니다.애플리케이션 유형\n웹 애플리케이션\n이름\n원하는 애플리케이션 명 입력\n승인된 리디렉션 URI\nhttp://localhost:8080/login/oauth2/code/google 로 지정해줬습니다. (x 표는 예전에 잘못입력했었던 정보입니다.)\n생성된 OAuth 클라이언트는 다운로드 받을 수 있습니다. 꼭 다운로드 받아서 안전한 위치에 보관해주시기 바랍니다.\n위에서 클라이언트 ID, 클라이언트 보안 비밀번호는 Spring Security 속성에는 아래와 같이 매칭됩니다.\nspring:\r\n  # ... \r\n  security:\r\n    oauth2:\r\n      client:\r\n        registration:\r\n          google:\r\n            client-id: 클라이언트 ID \r\n            client-secret: 클라이언트 보안 비밀번호\r\n            scope:\r\n              - email\r\n              - profile\r\n# ..."}},"/jwt-authentication-manager-way/security-auth-interaction":{"title":"Security Auth Interaction","data":{"시큐리티-인증-클래스들의-상호작용#시큐리티 인증 클래스들의 상호작용":"","authenticationmanager-authenticationprovider-providermanager#AuthenticationManager, AuthenticationProvider, ProviderManager":"ProviderManager 는 AuthenticationProvider 인스턴스들을 List 형태로 가지고있으면서 관리하는 객체입니다. 즉 Provider 들을 Manage 하는 객체입니다. 이 ProviderManager 는 AuthenticationManager 인터페이스를 구현한 기본 구현체입니다.","authenticationmanagerresolver#AuthenticationManagerResolver":"AuthenticationManager 를 기본 구현한 클래스는 ProviderManager 이고 스프링에서 기본으로 제공하지만, 여러가지 종류의 AuthenticationManager 를 구현해서 사용하고 싶을 수 있습니다. 인증 로직이 복잡해질 수록 한군데에 하드코딩한 로직들은 점점 갈 수록 장애를 내게 될 확률이 높기에 시기 적절하게 항상 기능별로 모듈화를 해두는 것이 좋습니다. 따라서 용도별로 AuthenticationManager 를 분리해서 정의하는 경우가 많습니다.이렇게 용도별로 분리해둔 AuthenticationManager 들 중에서 Filter 가 어떤 AuthenticationManager 를 사용할지 결정할 수 있도록 하는 역할을 하는 것이 AuthenticationManagerResolver 입니다. 말 그대로 AuthenticationManager 를 resolve 하는 역할을 수행합니다.\n예를 들어 아래와 같은 시큐리티 클래스가 있다고 해보겠습니다.\n@Configuration\r\npublic class SucurityConfig {\r\n    // ...\r\n}\n그리고 customerAuthenticationManager 라는 이름의 Bean 을 아래와 같이 생성한다고 해보겠습니다. 예제이기에 간단하게 인라인 형식으로 단순하게 만들었습니다.\n@Bean\r\nAuthenticationManager customersAuthenticationManager() {\r\n    return authentication -> {\r\n        if (isCustomer(authentication)) {\r\n            return new UsernamePasswordAuthenticationToken(/*credentials*/);\r\n        }\r\n        throw new UsernameNotFoundException(/*principal name*/);\r\n    };\r\n}\n이번에는 employeesAuthenticationManager 라는 이름의 Bean 을 아래와 같이 생성해봅니다. 예제 수준의 단순한 인라인 정 코드입니다.\n@Bean\r\npublic AuthenticationManager employeesAuthenticationManager() {\r\n    return authentication -> {\r\n        if (isEmployee(authentication)) {\r\n            return new UsernamePasswordAuthenticationToken(/*credentials*/);\r\n        }\r\n        throw new UsernameNotFoundException(/*principal name*/);\r\n    };\r\n}\n이렇게 정의해둔 AuthenticationManager 들은 어떤 기준에 의해 선택이 될수 있어야 합니다. AuthenticationManagerResolver 에는 이런 AuthenticationManager 들을 특정 기준에 의해 선택하는 코드를 작성합니다.\nAuthenticationManagerResolver<HttpServletRequest> resolver() {\r\n    return request -> {\r\n        if (request.getPathInfo().startsWith(\"/employee\")) {\r\n            return employeesAuthenticationManager();\r\n        }\r\n        return customersAuthenticationManager();\r\n    };\r\n}","reactiveauthenticationmanagerresolver#ReactiveAuthenticationManagerResolver":"이번에는 위에서 살펴본 AuthenticationManager 를 Reactive 버전으로 작성해봅니다.예를 들어 아래와 같은 시큐리티 클래스가 있다고 해보겠습니다. 아까와 달라진 점은 @EnableWebFluxSecurity, @EnableReactiveMethodSecurity 을 추가해줬다는 점입니다.\n@EnableWebFluxSecurity\r\n@EnableReactiveMethodSecurity\r\npublic class SucurityConfig {\r\n    // ...\r\n}\n그리고 customerAuthenticationManager 라는 이름의 Bean 을 아래와 같이 생성한다고 해보겠습니다. 예제이기에 간단하게 인라인 형식으로 단순하게 만들었습니다. 아까와 달라진 점은 ReactiveAuthenticationManager 를 반환한다는 점입니다.\n@Bean\r\npublic ReactiveAuthenticationManager customersAuthenticationManager() {\r\n    return authentication -> {\r\n        if (isCustomer(authentication)) {\r\n            return new UsernamePasswordAuthenticationToken(/*credentials*/);\r\n        }\r\n        throw new UsernameNotFoundException(/*principal name*/);\r\n    };\r\n}\n이번에는 employeesAuthenticationManager 라는 이름의 Bean 을 아래와 같이 생성해봅니다. 예제 수준의 단순한 인라인 코드입니다. 아까와 달라진 점은 ReactiveAuthenticationManager 를 반환한다는 점입니다.\n@Bean\r\npublic ReactiveAuthenticationManager employeesAuthenticationManager() {\r\n    return authentication -> {\r\n        if (isEmployee(authentication)) {\r\n            return new UsernamePasswordAuthenticationToken(/*credentials*/);\r\n        }\r\n        throw new UsernameNotFoundException(/*principal name*/);\r\n    };\r\n}\n이렇게 정의한 ReactiveAuthenticationManager 들은 아래와 같이 ReactiveAuthenticationManagerResolver 에서 적절한 ReactiveAuthenticationManager 를 선택하도록 정의하는 것이 가능합니다.\nReactiveAuthenticationManagerResolver<ServerWebExchange> resolver() {\r\n    return exchange -> {\r\n        if (match(exchange.getRequest(), \"/employee\")) {\r\n            return Mono.just(employeesAuthenticationManager());\r\n        }\r\n        return Mono.just(customersAuthenticationManager());\r\n    };\r\n}","foobar-user-는#foobar-user 는?":"제가 작성한 foobar-user 에서는 ReactiveAuthenticationManagerResolver 까지 사용하지는 않았고 1개의 ReactiveAuthenticationManager를 Filter 에 등록해서 사용하는 방식으로 아래와 같이 사용했습니다.\n@RequiredArgsConstructor\r\n@EnableWebFluxSecurity\r\n@EnableReactiveMethodSecurity\r\n@Configuration\r\npublic class SecurityConfig {\r\n\r\n  @Bean\r\n  public SecurityWebFilterChain filterChain(\r\n      ServerHttpSecurity httpSecurity,\r\n      JwtServerAuthenticationConverter converter,\r\n      JwtAuthenticationManager authenticationManager\r\n  ){\r\n    // (1)\r\n    var authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);\r\n    authenticationWebFilter.setServerAuthenticationConverter(converter);\r\n\r\n    return httpSecurity\r\n        // ...\r\n        .csrf(csrfSpec -> csrfSpec.disable())\r\n        .formLogin(formLoginSpec -> formLoginSpec.disable())\r\n        .httpBasic(httpBasicSpec -> httpBasicSpec.disable())\r\n        // ...\r\n        .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION)\r\n        .build();\r\n  }\r\n}\n(1)\nAuthenticationWebFilter 객체 생성시에 JwtAuthenticationManager 를 전달해줍니다.\nJwtAuthenticationManager 의 내용은 아래에 정리해두었습니다.\n아래는 JwtAuthenticationManager 클래스의 내용입니다. 이 코드에 대한 자세한 설명은 ReactiveAuthenticationManager방식의 JWT 인증 # JwtAuthenticationManager 문서에 정리해두었습니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  private final JwtSupport jwtSupport;\r\n  private final CustomUserDetailsService userDetailsService;\r\n\r\n  @Override\r\n  public Mono<Authentication> authenticate(Authentication authentication) {\r\n    return Mono.justOrEmpty(authentication)\r\n        .filter(auth -> auth instanceof BearerToken)\r\n        .cast(BearerToken.class)\r\n        .map(bearerToken -> degenerateToken(bearerToken))\r\n        .flatMap(jwtDto -> validateJwt(jwtDto))\r\n        .flatMap(jwtDto -> findUserById(jwtDto.id()))\r\n        .onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\r\n  }\r\n\r\n  public JwtDto degenerateToken(BearerToken token){\r\n    return jwtSupport.degenerateToken(SecurityProperties.key, token.getJwt());\r\n  }\r\n\r\n  public Mono<JwtDto> validateJwt(JwtDto jwtDto){\r\n    if(jwtSupport.checkIfNotExpired(jwtDto.expiration())){\r\n      return Mono.just(jwtDto);\r\n    }\r\n    return Mono.error(new IllegalArgumentException(\"Token Invalid\"));\r\n  }\r\n\r\n  private Mono<Authentication> findUserById(String userId){\r\n    return userDetailsService\r\n        .findByUsername(userId)\r\n        .map(userDetails -> {\r\n          var authentication = new UsernamePasswordAuthenticationToken(\r\n              userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities()\r\n          );\r\n          SecurityContextHolder.getContext().setAuthentication(authentication);\r\n          return authentication;\r\n        });\r\n  }\r\n  \r\n}"}},"/servlet-security-auth/intro":{"title":"Intro","data":{}},"/jwt-basic/jwt-generate-degenerate-example":{"title":"JWT Generate Degenerate Example","data":{"jwt-생성-분해#JWT 생성, 분해":"이번 문서에서는 Java 기반으로 JWT 를 생성하고 분해하는 예제를 살펴봅니다.","의존성-추가#의존성 추가":"jjwt-api, jjwt-impl 등의 라이브러리는 github.com/jwtk/jjwt 에서 제공하는 라이브러리입니다.\ndependencies {\r\n    // ...    \r\n\timplementation 'io.jsonwebtoken:jjwt-api:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-impl:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-jackson:0.11.2'\r\n    // ...\r\n}\nJava 기반의 JWT 라이브러리를 선택하는 것은 jwt.io/libraries?language=java 에서 확인 가능합니다. 저의 경우에는 io.jsonwebtoken 에서 제공하는 라이브러리를 선호하기 때문에 io.jsonwebtoken 계열의 라이브러리를 선택했습니다. 캡쳐에서 보이듯 지원되는 알고리즘이 많은 것을 확인 가능합니다. 하단의 View Repo 버튼을 클릭하면 Github Repository 로 이동합니다.\njwt.io/libraries?language=java 페이지에서 가장 최상단에 나타나는 라이브러리가 지원되는 알고리즘이 많은 것은 아닙니다. 예를 들어 가장 최상단에 나타난 com.auth0 에서 제공하는 JWT 라이브러리는 일부 알고리즘이 지원되지 않음을 확인 가능합니다. 꼭 지원되는 알고리즘을 확인하시고 라이브러리를 선택하시기를 바랍니다.","언어별로-지원되는-jwt-라이브러리-확인#언어별로 지원되는 JWT 라이브러리 확인":"jwt.io 에서는 Libraries 탭을 클릭하면 https://jwt.io/libraries 로 이동됩니다. 여기서 모든 언어에서 지원되는 JWT 라이브러리들이 리스팅 되어서 보여지고 Filter by 메뉴에서 원하는 언어를 클릭해서 원하는 언어에서 지원되는 JWT 공식 라이브러리들과 지원되는 알고리즘들을 확인하실 수 있습니다.","secret-정의-hs256-기반의-key-생성#Secret 정의, HS256 기반의 Key 생성":"Secret 으로 사용할 문자열을 정의하고 이 문자열을 HS256 기반의 알고리즘으로 Key 를 생성합니다.저의 경우는 SecurityProperties.java 라는 별도의 클래스에 Key, Secret 을 정의해두었습니다.\npublic class SecurityProperties {\r\n  public static final String SECRET = \"\";\r\n  public static final Key key = Keys.hmacShaKeyFor(SECRET.getBytes(StandardCharsets.UTF_8));\r\n}","jwt-생성-분해-1#JWT 생성, 분해":"JWT 생성, 분해를 하는 코드는 아래와 같습니다. 간단한 테스트 코드를 통해 확인해봅니다.\n// ...\r\n\r\npublic class JwtSupportTest {\r\n  // ...\r\n\r\n  @DisplayName(\"JWT_생성_분해_테스트\")\r\n  @Test\r\n  public void TEST_JWT_생성_분해_테스트(){\r\n    // (1)\r\n    // given\r\n    String username = \"John Deer\";\r\n    String userId = \"jdman\";\r\n    Key key = SecurityProperties.key;\r\n\r\n    // (2)\r\n    // when\r\n    // JWT 생성\r\n    String jwt = Jwts.builder()\r\n      .setSubject(username)\r\n      .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n      .claim(\"id\", userId)\r\n      .claim(\"username\", username)\r\n      .signWith(key, SignatureAlgorithm.HS256)\r\n      .compact();\r\n\r\n    // then\r\n    // JWT 분해\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(jwt);\r\n\r\n    assert claimsJws.getBody().get(\"id\", String.class).equals(userId);\r\n    assert claimsJws.getBody().get(\"username\", String.class).equals(username);\r\n  }\r\n  \r\n}\n(1)John Deer 라는 이름과 jdman 이라는 userId 에 대해서 Key를 기반으로 JWT를 생성합니다. JWT는 하나의 문자열 토큰입니다. Key 는 위에서 설명했듯 SecurityProperties 라는 클래스에서 특정 문자열 시크릿을 static 하게 HS256 기반의 알고리즘으로 생성해둔 Key 입니다.(2)JWT 문자열을 생성 시에는 Key 를 기반으로 서명을 생성합니다. 그리고 Jwt에 필수적으로 저장할 claim 들은 id 로 지정했습니다.\n(3)생성한 JWT 문자열에서 id, username 등과 같은 정보를 추출해냅니다.","컴포넌트로-정의#컴포넌트로 정의":"제 경우에는 위의 코드들을 하나의 컴포넌트로 생성했고, 스프링 컨테이너에서 객체를 생성해서 관리하도록 해두었습니다.\npackage io.chagchagchag.example.foobar.core.user.jwt;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport io.jsonwebtoken.JwtParser;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class JwtSupport {\r\n  public String generateToken(Key key, String userId, String username){\r\n    return Jwts.builder()\r\n        .setSubject(username)\r\n        .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n        .claim(\"id\", userId)\r\n        .claim(\"username\", username)\r\n        .signWith(key, SignatureAlgorithm.HS256)\r\n        .compact();\r\n  }\r\n\r\n  public void addJwtAtResponseHeader(String jwt, ServerHttpResponse response){\r\n    response.getHeaders().add(\"Authorization\", String.format(\"Bearer %s\", jwt));\r\n  }\r\n\r\n  public JwtDto degenerateToken(Key key, String token){\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(token);\r\n\r\n    return new JwtDto(\r\n        claimsJws.getBody().get(\"id\", String.class),\r\n        claimsJws.getBody().get(\"username\", String.class),\r\n        claimsJws.getBody().getExpiration()\r\n    );\r\n  }\r\n\r\n  public Boolean checkContainsBearer(String header){\r\n    var len = \"Bearer \".length();\r\n    return header.substring(0, len).equalsIgnoreCase(\"Bearer\");\r\n  }\r\n\r\n  // 만료되면 true\r\n  // 만료되지 않았으면 false\r\n  public Boolean checkIfNotExpired(Date expiration){\r\n    return expiration.after(new Date());\r\n  }\r\n}"}},"/jwt-basic/what-is-jwt":{"title":"What Is JWT","data":{"jwt-의-개념#JWT 의 개념":"참고한 자료는 아래와 같습니다. 아래 자료의 내용을 일부 의역 + 요약했습니다.\nhttp://jwt.io/introduction","jwt-란#JWT 란?":"JWT 는 RFC7519 로 등록된 하나의 기술 표준인데 사전적 정의는 \"당사자 간에 정보를 JSON 개체로 안전하게 전송하기 위한 간결하고 독립적인 방법을 정의하는 개방형 표준(RFC7519)\" 입니다.주로 HMAC 알고리즘 또는 RSA 알고리즘을 통해 인코딩/디코딩을 합니다. JWT는 '서명된 토큰'에 중점을 둡니다. 당사자 간에 Secret 을 제공할 수도 있지만 '서명된 토큰'을 주고받는 것에 중점을 두고 있습니다.서명된 토큰에는 이 토큰 내에 포함된 어떤 정보(=클레임)의 무결성을 확인할 수 있게 해줍니다.개인적인 경험으로는 JWT 내에 여러가지 값을 넣을 수도 있지만 주로 변하지 않을 값들 (id, email) 등과 같은 값을 넣어두는게 좋고 자주 변하는 값 (profileImageId, phoneNumber 등) 과 같은 값들을 넣어두는 것은 비즈니스 요구사항 발생시 앱 재배포 이슈까지 따라올 수 있기에 좋지 않은 선택입니다.","jwt-의-구조#JWT 의 구조":"JWT 는 헤더, 페이로드, 서명(Signature) 로 구성됩니다.\r\n예를 들면 . 으로 구분된 아래와 같은 형식으로 구성됩니다.\n{header}.{Payload}.{Signature}\nxxxxx.yyyyy.zzzzz","header-헤더---어떤-알고리즘을-사용해서-서명을-했는지#header (헤더) - \"어떤 알고리즘을 사용해서 서명을 했는지\"":"header 는 아래와 같은 구조의 문자열로 구성되는데, 이 문자열을 Base64 URL 로 인코딩해서 JWT 의 첫번째 부분에 지정합니다.\n{\r\n    \"alg\": \"HS256\",\r\n    \"typ\": \"JWT\"\r\n}","payload-페이로드---jwt에-실어보낼-페이로드#payload (페이로드) - \"JWT에 실어보낼 페이로드\"":"페이로드는 클레임들의 집합입니다.\ne.g.\n{\r\n  \"sub\": \"1234567890\", // 등록된 클레임\r\n  \"name\": \"John Doe\", // 개인클레임 \r\n  \"admin\": true // 개인클레임\r\n}\n페이로드에는 클레임을 포함하고 있습니다.클레임은 일종의 엔티티 및 부가정보에 대한 선언문이라고 생각하면 됩니다.클레임의 유형은 3가지가 있습니다.\nRegistered Claim\n필수는 아닙니다. 하지만 권장됩니다.\nClaim 들의 집합인데, 권장되는 Claim 들의 집합입니다. 필수는 아닙니다.\n안넣어도 되고, 엄청 중요한 것은 아닙니다.\ne.g. iss(issuer), exp(expiration time), sub(subject), aud(audience), 그 외 기타\nPublic Claim\nPrivate Claim\n개인이 필요할 때 만들어서 추가해서 넣을 수 있는 클레임입니다.\n사용자임을 식별할 수 있는 어떠한 primary key 같은 것들을 Primary Claim 에 넣는 경우가 많습니다.\n개인적으로 추가되는 정보임을 나타내는 정보\ne.g. \"user_id\" : 1\n핵심은 페이로드에 무엇을 넣는지입니다. 그 중 가장 중요한 것은 Private Claim (개인 클레임) 입니다. 예를 들면 이 개인 클레임(Private Claim)에는 user_id 나 primary_key 같은 식별 가능한 키를 암호화해서 넣는 편입니다.","signature-서명#Signature (서명)":"header, payload 와 secret(개인키, 일반적으로 서버에서 따로 보안된 위치에 따로 보관)를 HMAC 으로 암호화하는 것을 의미합니다. HS256 이라는 것은 HMAC SHA 256 이라는 알고리즘을 의미합니다.secret 이라는 것은 사용자가 지정한 임의의 문자열입니다.예를 들면 'abcdefghijklmnopqrstuvwxyz1234567' 같은 문자열을 팀에서 키를 조합할때 사용할 비밀키로 지정했을 때 이 'abcdefghijklmnopqrstuvwxyz1234567 라는 문자열과 header, payload 값을 HMACSHA256 함수에 인자로 해서 생성하면 서명된 문자열이 도출됩니다.이것을 서명이라고 이야기합니다.\nHMACSHA256(\r\n  base64UrlEncode(header) + \".\" +\r\n  base64UrlEncode(payload),\r\n  secret)","최종-산출-결과#최종 산출 결과":"최종적으로 만들어진 JWT 는 아래와 같은 모습을 가지게 됩니다.\n이미지 출처 : https://jwt.io/introduction\n만약 최종적으로 만들어진 JWT를 분해해서 확인해보고 싶다면 아래와 같이 jwt.io.Debugger 를 활용하시면 웹 GUI 로도 확인이 가능합니다.\n이미지 출처 : https://jwt.io/introduction"}},"/oauth2/what-is-oauth":{"title":"What Is Oauth","data":{"oauth-핵심-개념#OAuth 핵심 개념":"OAuth 는 제 3의 서비스에 계정관리를 맡기는 방식을 의미합니다. 예를 들면 구글 로그인 기능으로 로그인을 하는 방식을 의미합니다.\nAuthorization, Authentication 이라는 용어 자체를 한국 단어로 인증, 인가 로 표현하는데, 실제 정해진 단어가 있는지는 확실치가 않고, 단어가 오용될 수도 있는 소지가 있기에 영어단어를 그대로 사용하겠습니다. Authorization, Authentication 이 혼용될때에만 영어단어로 표기하겠습니다. 일반적인 'OAuth 인증' 등과 같은 단어는 그대로 사용합니다.","oauth-의-핵심-주체#OAuth 의 핵심 주체":"OAuth 에서 주요하게 행동을 하는 4 종류의 주체들이 있습니다. 이 요소들을 정리해보면 아래와 같습니다. 한글로 번역된 용어보다 영어 용어를 보는 것이 기억이 잘 되기아 가급적 영어 용어로 기억하길 추천드립니다.","resource-owner-리소스-오너#Resource Owner (리소스 오너)":"서비스에 자신을 등록한 사용자를 의미합니다. 자기 자신의 정보를 인증 서버에서 사용할 수 있도록 동의를 해서 서비스에 자기자신의 정보의 사용을 허가한 주체입니다.","resource-server-리소스-서버#Resource Server (리소스 서버)":"Resource Owner 의 정보를 가지고 있고, 이 정보를 보호하고 있는 주체입니다.","authorization-server-인증-서버#Authorization Server (인증 서버)":"클라이언트에게 토큰을 발급하는 주체입니다. 토큰을 사용하면 클라이언트가 Resource Owner 의 정보에 접근이 가능합니다. 일반적으로 go, java, python 등의 언어로 구글 Open API 프로그램을 작성할 때 이 프로그램이 클라이언트 역할을 합니다. Authorization Server 는 구글을 예로 들면, 구글의 인증만을 수행하는 서버를 의미합니다.","client-application-클라이언트-애플리케이션#Client Application (클라이언트 애플리케이션)":"우리가 만들게 될 go, java, python 등의 언어로 작성한 구글 Open API 프로그램이 Client Application 에 해당합니다.","authorization-방식#Authorization 방식":"Client Application 은 Resource Owner 가 Ahtorization Server 에서 Authorization 을 거치면 토큰을 획득하게 되는데, 이렇게 해서 Resource Owner 의 정보를 획득 가능합니다.Resource Owner 의 정보를 취득하는 방식은 4 종류가 있습니다.\nAuthorization Code Grant Type (권한 부여 코드 승인 타입)\nImplicit Grant Type (암시적 승인 타입)\nResource Owner Password Credentials (리소스 소유자 암호 자격 증명 승인 타입)\nClient Credentials Grant (클라이언트 자격 증명 승인 타입)","authorization-code-grant-type-권한-부여-코드-승인-타입#Authorization Code Grant Type (권한 부여 코드 승인 타입)":"OAuth2.0 사용 시 가장 대중화된 인증 방식입니다. 클라이언트가 Resource Owner 에 대한 액세스 토큰, 접근 권한 코드를 발급받는 방식입니다.접근 권한 코드라는 것은 Resource Owner 가 가진 권한을 부여받은 코드입니다.Authorization Code Grant Type 방식의 Authorization 과정은 아래와 같습니다.\n참고 : docs.vmware.com - SSO/GUID Grant Types\n구글 이미지 검색으로 authorization code grant type 을 검색","implicit-grant-type-암시적-승인-타입#Implicit Grant Type (암시적 승인 타입)":"서버 없이 동작해야 하는 Javascript 애플리케이션에서 사용할 수 있는 방식입니다. 다른 정보 없이 액세스 토큰만을 부여받는 방식입니다.클라이언트(Javascript)가 요청을 보냈을 때 리소스의 Authorization 과정만을 거친 후 액세스 토큰을 제공받습니다. 이때 별도의 접근 권한 코드 등을 획득하는 부가적인 과정을 거치지 않습니다.접근 권한 코드 등과 같은 별도의 정보가 없기에 '모호하다'는 의미인 Implicit 이라는 단어가 사용되었음에 주목해주세요.","resource-owner-password-credentials-리소스-소유자-암호-자격증명-승인-타입#Resource Owner Password Credentials (리소스 소유자 암호 자격증명 승인 타입)":"클라이언트의 패스워드를 이용해서 액세스 토큰에 대한 사용자의 자격 증명을교환하는 방식입니다.","client-credentials-grant-클라이언트-자격-증명-승인-타입#Client Credentials Grant (클라이언트 자격 증명 승인 타입)":"클라이언트가 컨텍스트 외부에서 얻은 액세스 토큰을 통해 리소스에 접근하는 방식입니다.","이번-문서에서는#이번 문서에서는":"이번문서에서는 Authorization Code Grant (인증 코드 부여) 방식의 인증방식만을 정리합니다.","권한-요청-파라미터#권한 요청 파라미터":"","권한-요청#권한 요청":"go, java, python 등의 언어로 작성한 구글 Open API 프로그램이 Client Application 이 특정 사용자 데이터에 접근하기 위해 Authorization Server 에 요청을 보내는 것을 권한 요청이라고 합니다.","파라미터#파라미터":"예를 들면 아래와 같은 형식의 파라미터를 사용해서 권한 요청을 수행하는 것이 가능합니다.\nGET some-example.com/auth? \\\r\n\tclient_id=1111& \\\r\n\tredirect_uri=http://localhost:7777/myapp& \\\r\n\tresponse_type=code& \\\r\n\tscope=profile\nclient_id\n인증서버에서 Client Application 에 부여한 id 입니다.\n이 값은 Client Application 을 구글과 같은 OAuth 서비스에 등록할 때 서비스 내에서 생성한 값 입니다.\n관리 콘솔 등에서 확인 가능합니다\nredirect_uri\n로그인 성공시 이동할 uri 를 의미합니다.\nresponse_type\nClient Application 이 제공받으려 하는 응답 타입입니다.\n접근 권한 코드를 받으려 할 경우에는 반드시 code 파라미터를 포함해야 합니다.\nAuthorization Code Grant 방식의 인증에서는 접근권한 코드가 필요하기에 code 파라미터는 반드시 필요합니다.\nscope\n제공받고자 하는 Resource Owner 의 정보 목록을 의미합니다.","resource-owner-의-데이터-접근-동의#Resource Owner 의 데이터 접근 동의":"Authorization Server 에 처음 요청을 보낼 경우 사용자에게 보이는 페이지를 로그인 페이지로 변경 후 사용자의 데이터에 대한 접근 동의를 얻는 과정을 거치는데 이 과정은 최초 1회 수행합니다. Authorization Server 는 이 때 동의 내용을 저장하게 되며, 이후의 과정부터는 Authorization Server 에서 동의서를 저장하고 있기에 로그인 절차만을 수행합니다.","authorization-code-리다이렉션#Authorization Code 리다이렉션":"Resource Owner 인 사용자가 로그인에 성공하면 권한 요청 시에 파라미터로 지정한 redirect_uri 로 리다이렉션 됩니다. 이때 리다이렉션 되는 uri 의 파라미터에는 인증코드가 함께 제공됩니다. 예를 들면 아래와 같은 uri 로 리다이렉트 되게 됩니다.\nGET http://localhost:7777/my-travel-app?code=33557799aa","액세스-토큰-응답이란#액세스 토큰 응답이란?":"Authorization Code 를 받은 후에는 이것을 비대칭 키 기반으로 암호화된 Access Token 으로 교환받아야 합니다.\n참고 : docs.vmware.com - SSO/GUID Grant Types\n구글 이미지 검색으로 authorization code grant type 을 검색\n예를 들면 아래와 같은 HTTP Post 요청으로 수행하게 됩니다.\nPOST some-example.com/token\r\n{\r\n  \"client_id\": \"1111\",\r\n  \"client_secret\": \"aa112233\",\r\n  \"redirect_uri\": \"http://localhost:7777/gogogo\",\r\n  \"grant_type\": \"authorization_token\",\r\n  \"code\": \"33557799aa\"\r\n}\nclient_secret : 구글 콘솔에서 확인 가능한 Client Application 에 대한 Secret 키 입니다.\ngrant_type : authorization_token 으로 지정해줬습니다."}}}