{"/jwt-authentication-manager-way/example":{"title":"Example","data":{}},"/":{"title":"Introduction","data":{"":"Welcome to Nextra! This is a basic docs template. You can use it as a starting point for your own project :)","what-is-nextrazxcv#What is Nextra?zxcv":"A simple, powerful and flexible site generation framework with everything you love from Next.js.","documentation#Documentation":"The documentation is available at https://nextra.site."}},"/jwt-basic/what-is-jwt":{"title":"What Is JWT","data":{"jwt-의-개념#JWT 의 개념":"참고한 자료는 아래와 같습니다. 아래 자료의 내용을 일부 의역 + 요약했습니다.\nhttp://jwt.io/introduction","jwt-란#JWT 란?":"JWT 는 RFC7519 로 등록된 하나의 기술 표준인데 사전적 정의는 \"당사자 간에 정보를 JSON 개체로 안전하게 전송하기 위한 간결하고 독립적인 방법을 정의하는 개방형 표준(RFC7519)\" 입니다.주로 HMAC 알고리즘 또는 RSA 알고리즘을 통해 인코딩/디코딩을 합니다. JWT는 '서명된 토큰'에 중점을 둡니다. 당사자 간에 Secret 을 제공할 수도 있지만 '서명된 토큰'을 주고받는 것에 중점을 두고 있습니다.서명된 토큰에는 이 토큰 내에 포함된 어떤 정보(=클레임)의 무결성을 확인할 수 있게 해줍니다.개인적인 경험으로는 JWT 내에 여러가지 값을 넣을 수도 있지만 주로 변하지 않을 값들 (id, email) 등과 같은 값을 넣어두는게 좋고 자주 변하는 값 (profileImageId, phoneNumber 등) 과 같은 값들을 넣어두는 것은 비즈니스 요구사항 발생시 앱 재배포 이슈까지 따라올 수 있기에 좋지 않은 선택입니다.","jwt-의-구조#JWT 의 구조":"JWT 는 헤더, 페이로드, 서명(Signature) 로 구성됩니다.\r\n예를 들면 . 으로 구분된 아래와 같은 형식으로 구성됩니다.\n{header}.{Payload}.{Signature}\nxxxxx.yyyyy.zzzzz","header-헤더---어떤-알고리즘을-사용해서-서명을-했는지#header (헤더) - \"어떤 알고리즘을 사용해서 서명을 했는지\"":"header 는 아래와 같은 구조의 문자열로 구성되는데, 이 문자열을 Base64 URL 로 인코딩해서 JWT 의 첫번째 부분에 지정합니다.\n{\r\n    \"alg\": \"HS256\",\r\n    \"typ\": \"JWT\"\r\n}","payload-페이로드---jwt에-실어보낼-페이로드#payload (페이로드) - \"JWT에 실어보낼 페이로드\"":"페이로드는 클레임들의 집합입니다.\ne.g.\n{\r\n  \"sub\": \"1234567890\", // 등록된 클레임\r\n  \"name\": \"John Doe\", // 개인클레임 \r\n  \"admin\": true // 개인클레임\r\n}\n페이로드에는 클레임을 포함하고 있습니다.클레임은 일종의 엔티티 및 부가정보에 대한 선언문이라고 생각하면 됩니다.클레임의 유형은 3가지가 있습니다.\nRegistered Claim\n필수는 아닙니다. 하지만 권장됩니다.\nClaim 들의 집합인데, 권장되는 Claim 들의 집합입니다. 필수는 아닙니다.\n안넣어도 되고, 엄청 중요한 것은 아닙니다.\ne.g. iss(issuer), exp(expiration time), sub(subject), aud(audience), 그 외 기타\nPublic Claim\nPrivate Claim\n개인이 필요할 때 만들어서 추가해서 넣을 수 있는 클레임입니다.\n사용자임을 식별할 수 있는 어떠한 primary key 같은 것들을 Primary Claim 에 넣는 경우가 많습니다.\n개인적으로 추가되는 정보임을 나타내는 정보\ne.g. \"user_id\" : 1\n핵심은 페이로드에 무엇을 넣는지입니다. 그 중 가장 중요한 것은 Private Claim (개인 클레임) 입니다. 예를 들면 이 개인 클레임(Private Claim)에는 user_id 나 primary_key 같은 식별 가능한 키를 암호화해서 넣는 편입니다.","signature-서명#Signature (서명)":"header, payload 와 secret(개인키, 일반적으로 서버에서 따로 보안된 위치에 따로 보관)를 HMAC 으로 암호화하는 것을 의미합니다. HS256 이라는 것은 HMAC SHA 256 이라는 알고리즘을 의미합니다.secret 이라는 것은 사용자가 지정한 임의의 문자열입니다.예를 들면 'abcdefghijklmnopqrstuvwxyz1234567' 같은 문자열을 팀에서 키를 조합할때 사용할 비밀키로 지정했을 때 이 'abcdefghijklmnopqrstuvwxyz1234567 라는 문자열과 header, payload 값을 HMACSHA256 함수에 인자로 해서 생성하면 서명된 문자열이 도출됩니다.이것을 서명이라고 이야기합니다.JWT 의 헤더는 아래와 같이 구성되는데 \"alg\" : \"HS256\" 이라는 것은 알고리즘으로 HMAC SHA 256 이라는 알고리즘을 사용하겠다는 것을 의미합니다.\n{\r\n    \"alg\": \"HS256\",\r\n    \"typ\": \"JWT\"\r\n}"}},"/jwt-basic/jwt-generate-degenerate-example":{"title":"JWT Generate Degenerate Example","data":{"jwt-생성-분해#JWT 생성, 분해":"이번 문서에서는 Java 기반으로 JWT 를 생성하고 분해하는 예제를 살펴봅니다.","의존성-추가#의존성 추가":"jjwt-api, jjwt-impl 등의 라이브러리는 github.com/jwtk/jjwt 에서 제공하는 라이브러리입니다.\ndependencies {\r\n    // ...    \r\n\timplementation 'io.jsonwebtoken:jjwt-api:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-impl:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-jackson:0.11.2'\r\n    // ...\r\n}\nJava 기반의 JWT 라이브러리를 선택하는 것은 jwt.io/libraries?language=java 에서 확인 가능합니다. 저의 경우에는 io.jsonwebtoken 에서 제공하는 라이브러리를 선호하기 때문에 io.jsonwebtoken 계열의 라이브러리를 선택했습니다. 캡쳐에서 보이듯 지원되는 알고리즘이 많은 것을 확인 가능합니다. 하단의 View Repo 버튼을 클릭하면 Github Repository 로 이동합니다.\njwt.io/libraries?language=java 페이지에서 가장 최상단에 나타나는 라이브러리가 지원되는 알고리즘이 많은 것은 아닙니다. 예를 들어 가장 최상단에 나타난 com.auth0 에서 제공하는 JWT 라이브러리는 일부 알고리즘이 지원되지 않음을 확인 가능합니다. 꼭 지원되는 알고리즘을 확인하시고 라이브러리를 선택하시기를 바랍니다.","언어별로-지원되는-jwt-라이브러리-확인#언어별로 지원되는 JWT 라이브러리 확인":"jwt.io 에서는 Libraries 탭을 클릭하면 https://jwt.io/libraries 로 이동됩니다. 여기서 모든 언어에서 지원되는 JWT 라이브러리들이 리스팅 되어서 보여지고 Filter by 메뉴에서 원하는 언어를 클릭해서 원하는 언어에서 지원되는 JWT 공식 라이브러리들과 지원되는 알고리즘들을 확인하실 수 있습니다.","secret-정의-hs256-기반의-key-생성#Secret 정의, HS256 기반의 Key 생성":"Secret 으로 사용할 문자열을 정의하고 이 문자열을 HS256 기반의 알고리즘으로 Key 를 생성합니다.저의 경우는 SecurityProperties.java 라는 별도의 클래스에 Key, Secret 을 정의해두었습니다.\npublic class SecurityProperties {\r\n  public static final String SECRET = \"\";\r\n  public static final Key key = Keys.hmacShaKeyFor(SECRET.getBytes(StandardCharsets.UTF_8));\r\n}","jwt-생성-분해-1#JWT 생성, 분해":"JWT 생성, 분해를 하는 코드는 아래와 같습니다. 간단한 테스트 코드를 통해 확인해봅니다.\n// ...\r\n\r\npublic class JwtSupportTest {\r\n  // ...\r\n\r\n  @DisplayName(\"JWT_생성_분해_테스트\")\r\n  @Test\r\n  public void TEST_JWT_생성_분해_테스트(){\r\n    // (1)\r\n    // given\r\n    String username = \"John Deer\";\r\n    String userId = \"jdman\";\r\n    Key key = SecurityProperties.key;\r\n\r\n    // (2)\r\n    // when\r\n    // JWT 생성\r\n    String jwt = Jwts.builder()\r\n      .setSubject(username)\r\n      .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n      .claim(\"id\", userId)\r\n      .claim(\"username\", username)\r\n      .signWith(key, SignatureAlgorithm.HS256)\r\n      .compact();\r\n\r\n    // then\r\n    // JWT 분해\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(jwt);\r\n\r\n    assert claimsJws.getBody().get(\"id\", String.class).equals(userId);\r\n    assert claimsJws.getBody().get(\"username\", String.class).equals(username);\r\n  }\r\n  \r\n}\n(1)John Deer 라는 이름과 jdman 이라는 userId 에 대해서 Key를 기반으로 JWT를 생성합니다. JWT는 하나의 문자열 토큰입니다. Key 는 위에서 설명했듯 SecurityProperties 라는 클래스에서 특정 문자열 시크릿을 static 하게 HS256 기반의 알고리즘으로 생성해둔 Key 입니다.(2)JWT 문자열을 생성 시에는 Key 를 기반으로 서명을 생성합니다. 그리고 Jwt에 필수적으로 저장할 claim 들은 id 로 지정했습니다.\n(3)생성한 JWT 문자열에서 id, username 등과 같은 정보를 추출해냅니다.","컴포넌트로-정의#컴포넌트로 정의":"제 경우에는 위의 코드들을 하나의 컴포넌트로 생성했고, 스프링 컨테이너에서 객체를 생성해서 관리하도록 해두었습니다.\npackage io.chagchagchag.example.foobar.core.user.jwt;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport io.jsonwebtoken.JwtParser;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class JwtSupport {\r\n  public String generateToken(Key key, String userId, String username){\r\n    return Jwts.builder()\r\n        .setSubject(username)\r\n        .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n        .claim(\"id\", userId)\r\n        .claim(\"username\", username)\r\n        .signWith(key, SignatureAlgorithm.HS256)\r\n        .compact();\r\n  }\r\n\r\n  public void addJwtAtResponseHeader(String jwt, ServerHttpResponse response){\r\n    response.getHeaders().add(\"Authorization\", String.format(\"Bearer %s\", jwt));\r\n  }\r\n\r\n  public JwtDto degenerateToken(Key key, String token){\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(token);\r\n\r\n    return new JwtDto(\r\n        claimsJws.getBody().get(\"id\", String.class),\r\n        claimsJws.getBody().get(\"username\", String.class),\r\n        claimsJws.getBody().getExpiration()\r\n    );\r\n  }\r\n\r\n  public Boolean checkContainsBearer(String header){\r\n    var len = \"Bearer \".length();\r\n    return header.substring(0, len).equalsIgnoreCase(\"Bearer\");\r\n  }\r\n\r\n  // 만료되면 true\r\n  // 만료되지 않았으면 false\r\n  public Boolean checkIfNotExpired(Date expiration){\r\n    return expiration.after(new Date());\r\n  }\r\n}"}},"/oauth2/Intro":{"title":"Intro","data":{}},"/jwt-authentication-manager-way/primary-concept":{"title":"Primary Concept","data":{}},"/servlet-security-auth/intro":{"title":"Intro","data":{}}}