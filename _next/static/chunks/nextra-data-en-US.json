{"/jwt-authentication-manager-way/example":{"title":"Example","data":{}},"/jwt-authentication-manager-way/primary-concept":{"title":"Primary Concept","data":{"reactiveauthenticationmanager-기반의-인증#ReactiveAuthenticationManager 기반의 인증":"스프링 시큐리티 관련 개념을 문서를 정리할 때마다 항상 고통스럽고 설명이 쉽지 않았었는데요. 최대한 쉽게 융통성 있게 설명해보겠습니다.이번 글에서는 SecurityConfig 를 필터체인을 Bean 으로 등록하는 방식을 설명합니다.  WebSecurityConfgiurerAdapter 를 상속해서 configure 메서드를 오버라이딩 하던 2.7.x 버전대의 시큐리티 코드 작성 방식은 이 글에서 다루지 않기로 했습니다. 저 역시도 이 방식을 본지가 꽤 오래되어서 기억이 안나기도 하고 지금와서 다시 예제를 하나 더 추가하기에는 시간도 부족해서 다루지 않기로 했습니다.","코드#코드":"모든 코드는 https://github.com/chagchagchag/webflux-mongo-mysql-redis/tree/main/foobar-user 에 있는 코드입니다.","의존성#의존성":"jwt 인증을 사용할 것이기에 jwt 인증과 security 의존성을 추가했습니다.\ndependencies{\r\n    // ...\r\n    \r\n    // security\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-security\")\r\n\r\n\t// jwt\r\n\timplementation(\"io.jsonwebtoken:jjwt-api:0.11.2\")\r\n\timplementation(\"io.jsonwebtoken:jjwt-impl:0.11.2\")\r\n\timplementation(\"io.jsonwebtoken:jjwt-jackson:0.11.2\")\r\n    \r\n    // ...\r\n}","securityconfigjava#SecurityConfig.java":"먼저 아래와 같은 SecurityConfig 클래스를 작성합니다. SecurityConfig 클래스 코드를 먼저 보는 이유는 어떤 기능을 추가할지 명확하게 보여주기 때문에 SecurityConfig 코드를 먼저 추가했습니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@EnableWebFluxSecurity // (0)\r\n@Configuration // (0)\r\npublic class SecurityConfig {\r\n\r\n  @Bean\r\n  public SecurityWebFilterChain filterChain(\r\n      ServerHttpSecurity httpSecurity,\r\n      JwtServerAuthenticationConverter converter, // (1)\r\n      JwtAuthenticationManager authenticationManager // (1)\r\n  ){\r\n    // (1)\r\n    var authenticationWebFilter = new AuthenticationWebFilter(authenticationManager);\r\n    authenticationWebFilter.setServerAuthenticationConverter(converter); // (1)\r\n\r\n    // (2)\r\n    return httpSecurity\r\n        // (3)\r\n        .exceptionHandling(exceptionHandlingSpec ->\r\n            exceptionHandlingSpec.authenticationEntryPoint(\r\n                (exchange, ex) -> Mono.fromRunnable(() -> {\r\n                  exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\r\n                  exchange.getResponse().getHeaders().set(HttpHeaders.WWW_AUTHENTICATE, \"Bearer\");\r\n                })\r\n            )\r\n        )\r\n        .csrf(csrfSpec -> csrfSpec.disable()) // (4)\r\n        .formLogin(formLoginSpec -> formLoginSpec.disable()) // (4)\r\n        .httpBasic(httpBasicSpec -> httpBasicSpec.disable()) // (4)\r\n        // (5)\r\n        .authorizeExchange(authorizeExchangeSpec ->\r\n            authorizeExchangeSpec\r\n                .pathMatchers(\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\")\r\n                .permitAll()\r\n                .pathMatchers(\"/swagger-ui.html\", \"/webjars/**\")\r\n                .permitAll()\r\n                .pathMatchers(\"/healthcheck/ready\")\r\n                .permitAll()\r\n                .pathMatchers(\"/api/users/login\", \"/api/users/signup\")\r\n                .permitAll()\r\n                .pathMatchers(\"/logout\", \"/api/users/profile/**\")\r\n                .hasAnyAuthority(\"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\")\r\n        )\r\n        // (6)\r\n        .headers(headerSpec -> headerSpec.frameOptions(frameOptionsSpec -> frameOptionsSpec.disable()))\r\n        // (7)\r\n        .addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION)\r\n        .build();\r\n  }\r\n}\n(0)\n@RequiredArgsConstructor\r\n@EnableWebFluxSecurity // (0)\r\n@Configuration // (0)\r\npublic class SecurityConfig {\r\n    // ...\r\n}\n@EnableWebFluxSecurity, @Configuration 을 추가해줍니다. @EnableWebFluxSecurity 는 ServerHttpSecurityConfiguration.class, WebFluxSecurityConfiguration.class, ReactiveOAuth2ClientImportSelector.class 설정을 포함하는 설정입니다.\n(1)AuthenticationWebFilter 객체를 생성합니다. 그리고 이 AuthenticationWebFilter 객체에는 직접 커스텀하게 구현해둔 JwtAuthenticationManager 객체를 바인딩해줍니다. 위의 코드에서는 AuthenticationWebFilter 생성자에 JwtAuthenticationManager 객체를 바인딩해줬습니다.직접 작성한 클래스인 JwtAuthenticationManager 클래스의 내용은 이글의 하단부에 설명 예정입니다.\n(2) HttpSecurity httpSecurityHttpSecurity httpSecurity  빈을 주입받은 후 httpSecurity객체의 build() 함수를 이용해서 SecurityWebFilterChain을 빈으로 등록합니다.\n(3)\nhttpSecurity\r\n// (3)\r\n.exceptionHandling(exceptionHandlingSpec ->\r\n    exceptionHandlingSpec.authenticationEntryPoint(\r\n        (exchange, ex) -> Mono.fromRunnable(() -> {\r\n          exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // (i)\r\n          exchange.getResponse().getHeaders().set(HttpHeaders.WWW_AUTHENTICATE, \"Bearer\"); // (ii)\r\n        })\r\n    )\r\n)\n(i)\n인증이 실패했을 때 StatusCode 를 어떤 것으로 내려줄지를 정의합니다.\n(ii)\nResponse 헤더에는 { WWW-Authenticate : Bearer }을 지정해주었습니다.\n(4)\nhttpSecurity\r\n// ...\r\n// (3)\r\n.csrf(csrfSpec -> csrfSpec.disable()) // (i)\r\n.formLogin(formLoginSpec -> formLoginSpec.disable()) // (ii)\r\n.httpBasic(httpBasicSpec -> httpBasicSpec.disable()) // (iii)\r\n// ...\n(i) : csrf를 비활성화합니다. (ii) : formLogin 을 비활성화 합니다.(iii) : httpBasic 역시 비활성화 합니다.\n(5)\nhttp\r\n// ...\r\n// (5)\r\n.authorizeExchange(authorizeExchangeSpec ->\r\n    authorizeExchangeSpec\r\n        // (i)\r\n        .pathMatchers(\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\")\r\n        .permitAll()\r\n        // (ii)\r\n        .pathMatchers(\"/swagger-ui.html\", \"/webjars/**\")\r\n        .permitAll()\r\n        // (iii)\r\n        .pathMatchers(\"/healthcheck/ready\")\r\n        .permitAll()\r\n        // (iv)\r\n        .pathMatchers(\"/api/users/login\", \"/api/users/signup\")\r\n        .permitAll()\r\n        // (v)\r\n        .pathMatchers(\"/logout\", \"/api/users/profile/**\")\r\n        .hasAnyAuthority(\"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\")\r\n)\n(i), (ii), (iii), (iv)\n\"/\", \"/welcome\", \"/img/**\", \"/api/users/signup\", \"/healthcheck/**\" 에 대해서는 permitAll 해줍니다.\n\"/swagger-ui.html\", \"/webjars/**\" 에 대해서 permitAll 해줍니다.\n\"/healthcheck/ready\" 에 대해서도 permitAll 해줍니다.\n\"/api/users/login\", \"/api/users/signup\" 에 대해서도 역시 permitAll 해줍니다.\n(v)\n\"/logout\", \"/api/users/profile/**\" 에 대해서는 \"ROLE_USER\", \"ROLE_MANAGER\", \"ROLE_ADMIN\" 의 권한에 대해서만 허용합니다.\n(6)X-Frame-Options 헤더를 적용합니다. X-Frame-Options는 웹 페이지를 <frame>, <iframe>, <embed>, <object>와 같은 태그를 사용하여 다른 웹 사이트에 삽입되는 것을 방지하는 데 사용합니다. 궁금하시다면 Chat GPT에게 Spring security 에서 headerSpec.frameOptions 는 무슨 기능을 해? 라고 질문해보시기 바랍니다.\nhttp\r\n// ...\r\n// (6)\r\n.headers(headerSpec -> headerSpec.frameOptions(frameOptionsSpec -> frameOptionsSpec.disable()))\r\n// ...\n(7)위에서 생성해둔 authenticationWebFilter 를 httpSecurity 객체에 추가해 준 후 HttpSecurity 의 build() 메서드를 통해 SecurityWebFilterChain 객체를 생성합니다.\nhttp\r\n// ...\r\n// (7)\r\n.addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION)\r\n.build();","jwtauthenticationmanager#JwtAuthenticationManager":"직접 작성한 JwtAuthenticationManager 클래스는 ReactiveAuthenticationManager 를 implements 해서 직접 작성한 클래스입니다. 이 글의 하단 부에 AuthenticationManager, AuthenticationManagerBuilder, HttpSecurity, AuthenticationManagerProvider 가 어떻게 상호작용하는지를 설명합니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\n// ...\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // (1)\r\n  private final JwtSupport jwtSupport; // (1)\r\n  private final CustomUserDetailsService userDetailsService; // (1)\r\n\r\n  // (2)\r\n  @Override\r\n  public Mono<Authentication> authenticate(Authentication authentication) {\r\n    return Mono.justOrEmpty(authentication)\r\n        .filter(auth -> auth instanceof BearerToken)\r\n        .cast(BearerToken.class)\r\n        .map(bearerToken -> degenerateToken(bearerToken))\r\n        .flatMap(jwtDto -> validateJwt(jwtDto))\r\n        .flatMap(jwtDto -> findUserById(jwtDto.id()))\r\n        .onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\r\n  }\r\n\r\n  // (3) 간단한 설명이기에 설명은 생략\r\n  public JwtDto degenerateToken(BearerToken token){\r\n    return jwtSupport.degenerateToken(SecurityProperties.key, token.getJwt());\r\n  }\r\n\r\n  // (4) 간단한 내용이기에 설명은 생략\r\n  public Mono<JwtDto> validateJwt(JwtDto jwtDto){\r\n    if(jwtSupport.checkIfNotExpired(jwtDto.expiration())){\r\n      return Mono.just(jwtDto);\r\n    }\r\n    return Mono.error(new IllegalArgumentException(\"Token Invalid\"));\r\n  }\r\n\r\n  // (5)\r\n  private Mono<Authentication> findUserById(String userId){\r\n    return userDetailsService\r\n        .findByUsername(userId)\r\n        .map(userDetails -> {\r\n          var authentication = new UsernamePasswordAuthenticationToken(\r\n              userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities()\r\n          );\r\n          SecurityContextHolder.getContext().setAuthentication(authentication);\r\n          return authentication;\r\n        });\r\n  }\r\n  \r\n}\n(1)\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // (1)\r\n  private final JwtSupport jwtSupport; // (1)\r\n  private final CustomUserDetailsService userDetailsService; // (1)\r\n    \r\n  // ...\r\n}\nJwtSupport 는 직접 정의했던 JwtSupport 클래스입니다. 자세한 내용은 JWT 생성, 분해 예제 에 정리해두었습니다.\nCustomUserDetailsService 를 바인딩해줬습니다. CustomUserDetailsService 에 대한 내용은 이글의 하단에 추가해두었습니다.\n(2)ReactiveAuthenticationManager interface의 authenticate(Authentication authentication) 을 override 하는 예제입니다.\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // ...\r\n  // (2)\r\n  @Override\r\n  public Mono<Authentication> authenticate(Authentication authentication) {\r\n    return Mono.justOrEmpty(authentication)\r\n        .filter(auth -> auth instanceof BearerToken)\r\n        .cast(BearerToken.class)\r\n        .map(bearerToken -> degenerateToken(bearerToken))\r\n        .flatMap(jwtDto -> validateJwt(jwtDto))\r\n        .flatMap(jwtDto -> findUserById(jwtDto.id()))\r\n        .onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\r\n  }\r\n  // ...\r\n}\n.filter(auth -> auth instanceof BearerToken)\nBearerToken 객체 타입인지 검사합니다. BearerToken 은 직접 정의한 객체입니다. 이 문서의 하단에 설명을 추가해두었습니다.\n.cast(BearerToken.class)\n현재 필터에 들어온 Authentication 객체를 BearerToken 타입으로 변환해줍니다.\n.map(bearerToken -> degenerateToken(bearerToken))\nbearerToken 이라는 이름의 Authentication 객체를 JwtDto 로 변환해줍니다.\ndegenerateToken(Authentication) 메서드는 (3) 에서 설명합니다.\n.flatMap(jwtDto -> validateJwt(jwtDto))\nvalidateJwt(jwtDto)에 대해서 변환되어진 jwtDto 에 대해서 Jwt 가 expiration 이 만료되었는지를 검사합니다.\n.flatMap(jwtDto -> findUserById(jwtDto.id()))\nvalidation 이 끝난 JwtDto 객체에 대해서 findUserById(...) 메서드를 통해서 실제 Database에 저장된 사용자인지를 검증합니다.\n.onErrorMap(throwable -> new IllegalArgumentException(\"INVALID JWT\"));\n에러가 났을 때는 어떤 Exception 을 낼지 정의합니다.\n(5)\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtAuthenticationManager implements ReactiveAuthenticationManager {\r\n  // ...\r\n  \r\n  // (5)\r\n  private Mono<Authentication> findUserById(String userId){\r\n    return userDetailsService\r\n        .findByUsername(userId)\r\n        .map(userDetails -> {\r\n          var authentication = new UsernamePasswordAuthenticationToken(\r\n              userDetails.getUsername(), userDetails.getPassword(), userDetails.getAuthorities()\r\n          );\r\n          SecurityContextHolder.getContext().setAuthentication(authentication);\r\n          return authentication;\r\n        });\r\n  }\r\n    \r\n  // ...\r\n}\nUserDetailsService 에서 findByUsername(userId) 를 통해서 userId에 대해서 사용자가 존재하는지 조회합니다. 조회 결과로 찾아낸 사용자에 대해서 Authentication 객체인 UsernamePasswordAuthenticationToken 으로 생성하고 이 객체를 SecurityContextHolder 에 Authentication 객체를 저장합니다.그리고 새롭게 업데이트 된 Authentication 객체를 return 하는 것으로 메서드의 실행을 마무리합니다.","jwtserverauthenticationconverter#JwtServerAuthenticationConverter":"이 JwtServerAuthenticationConverter 는 위의 SecurityConfig 코드 내에서 등록할 때에는 var authenticationWebFilter = new AuthenticationWebFilter(authenticationManager); 을 통해 생성한 AuthenticationWebFilter 객체에 대해 authenticationWebFilter.setServerAuthenticationConverter(converter); 코드를 통해서 컨버터를 등록합니다.\npackage io.chagchagchag.example.foobar.user.config.security;\r\n\r\nimport io.chagchagchag.example.foobar.dataaccess.user.security.BearerToken;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.web.server.authentication.ServerAuthenticationConverter;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.server.ServerWebExchange;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class JwtServerAuthenticationConverter implements ServerAuthenticationConverter {\r\n\r\n  @Override\r\n  public Mono<Authentication> convert(ServerWebExchange exchange) {\r\n    return Mono.justOrEmpty(exchange.getRequest())\r\n        .flatMap(serverHttpRequest -> Mono.justOrEmpty(serverHttpRequest.getHeaders()))\r\n        .flatMap(httpHeaders -> Mono.justOrEmpty(httpHeaders.getFirst(HttpHeaders.AUTHORIZATION)))\r\n        .filter(headerValue -> checkContainsBearer(headerValue))\r\n        .flatMap(jwt -> Mono.justOrEmpty(new BearerToken(jwt)));\r\n  }\r\n\r\n  public Boolean checkContainsBearer(String header){\r\n    var len = \"Bearer \".length();\r\n    return header.substring(0, len).equalsIgnoreCase(\"Bearer\");\r\n  }\r\n\r\n}\r\nconvert() 함수의 내용이 길어보이지만 serverHttpRequest.getHeaders().getFirst(HttpHeaders.AUTHORIZATION) 으로 얻은 String 내에 Bearer 문자열이 있는지를 검사하는 코드입니다. Null 체크를 해야 하기에 null 이 생길수 있는 부분들을 각각 Mono.flatMap 과 Mono.justOrEmpty() 로 분리해서 연결했습니다.","bearertoken#BearerToken":"위의 코드에서 사용한 BearerToken 은 아래와 같습니다. AbstractAuthenticationToken 객체를 상속한 클래스이고 SecurityFilterChain 에 등록된 필터가 검사할때는 Authentication 객체를 통해 검사를 수행하게 됩니다. (AbstractAuthenticationToken 객체는 Authentication 인터페이스를 implements 한 클래스입니다.)\npackage io.chagchagchag.example.foobar.dataaccess.user.security;\r\n\r\nimport lombok.Getter;\r\nimport org.springframework.security.authentication.AbstractAuthenticationToken;\r\nimport org.springframework.security.core.authority.AuthorityUtils;\r\n\r\n@Getter\r\npublic class BearerToken extends AbstractAuthenticationToken {\r\n  private final String jwt;\r\n  public BearerToken(String jwt){\r\n    super(AuthorityUtils.NO_AUTHORITIES);\r\n    this.jwt = jwt;\r\n  }\r\n\r\n  @Override\r\n  public Object getCredentials() {\r\n    return jwt;\r\n  }\r\n\r\n  @Override\r\n  public Object getPrincipal() {\r\n    return jwt;\r\n  }\r\n}","customuserdetailsservice#CustomUserDetailsService":"package io.chagchagchag.example.foobar.user.config.security;\r\n\r\nimport io.chagchagchag.example.foobar.dataaccess.user.repository.UserR2dbcRepository;\r\nimport io.chagchagchag.example.foobar.dataaccess.user.security.UserDetailsMapper;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.security.core.userdetails.ReactiveUserDetailsService;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.stereotype.Component;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RequiredArgsConstructor\r\n@Component\r\npublic class CustomUserDetailsService implements ReactiveUserDetailsService {\r\n  private final UserR2dbcRepository userR2dbcRepository;\r\n  private final UserDetailsMapper userDetailsMapper;\r\n\r\n  // id 가 존재하는지만 검사하고, 이것을 UserDetails 로 반환한다.\r\n  @Override\r\n  public Mono<UserDetails> findByUsername(String userId) {\r\n    return userR2dbcRepository\r\n        .findById(Long.parseLong(userId))\r\n        .map(userEntity -> userDetailsMapper.defaultUserDetails(userEntity));\r\n  }\r\n\r\n}","userdetailsmapper#UserDetailsMapper":"UserDetailsMapper 내의 defaultUserDetails 메서드는 아래와 같이 정의해두었습니다.\n// ...\r\n\r\nimport org.springframework.security.core.userdetails.User;\r\n// ...\r\n\r\n@Component\r\npublic class UserDetailsMapper {\r\n  public User defaultUserDetails(UserEntity userEntity){\r\n    return new User(\r\n        String.valueOf(userEntity.getId()),\r\n        userEntity.getPassword(),\r\n        true, true, true, true,\r\n        new ArrayList<GrantedAuthority>()\r\n    );\r\n  }\r\n}"}},"/jwt-basic/what-is-jwt":{"title":"What Is JWT","data":{"jwt-의-개념#JWT 의 개념":"참고한 자료는 아래와 같습니다. 아래 자료의 내용을 일부 의역 + 요약했습니다.\nhttp://jwt.io/introduction","jwt-란#JWT 란?":"JWT 는 RFC7519 로 등록된 하나의 기술 표준인데 사전적 정의는 \"당사자 간에 정보를 JSON 개체로 안전하게 전송하기 위한 간결하고 독립적인 방법을 정의하는 개방형 표준(RFC7519)\" 입니다.주로 HMAC 알고리즘 또는 RSA 알고리즘을 통해 인코딩/디코딩을 합니다. JWT는 '서명된 토큰'에 중점을 둡니다. 당사자 간에 Secret 을 제공할 수도 있지만 '서명된 토큰'을 주고받는 것에 중점을 두고 있습니다.서명된 토큰에는 이 토큰 내에 포함된 어떤 정보(=클레임)의 무결성을 확인할 수 있게 해줍니다.개인적인 경험으로는 JWT 내에 여러가지 값을 넣을 수도 있지만 주로 변하지 않을 값들 (id, email) 등과 같은 값을 넣어두는게 좋고 자주 변하는 값 (profileImageId, phoneNumber 등) 과 같은 값들을 넣어두는 것은 비즈니스 요구사항 발생시 앱 재배포 이슈까지 따라올 수 있기에 좋지 않은 선택입니다.","jwt-의-구조#JWT 의 구조":"JWT 는 헤더, 페이로드, 서명(Signature) 로 구성됩니다.\r\n예를 들면 . 으로 구분된 아래와 같은 형식으로 구성됩니다.\n{header}.{Payload}.{Signature}\nxxxxx.yyyyy.zzzzz","header-헤더---어떤-알고리즘을-사용해서-서명을-했는지#header (헤더) - \"어떤 알고리즘을 사용해서 서명을 했는지\"":"header 는 아래와 같은 구조의 문자열로 구성되는데, 이 문자열을 Base64 URL 로 인코딩해서 JWT 의 첫번째 부분에 지정합니다.\n{\r\n    \"alg\": \"HS256\",\r\n    \"typ\": \"JWT\"\r\n}","payload-페이로드---jwt에-실어보낼-페이로드#payload (페이로드) - \"JWT에 실어보낼 페이로드\"":"페이로드는 클레임들의 집합입니다.\ne.g.\n{\r\n  \"sub\": \"1234567890\", // 등록된 클레임\r\n  \"name\": \"John Doe\", // 개인클레임 \r\n  \"admin\": true // 개인클레임\r\n}\n페이로드에는 클레임을 포함하고 있습니다.클레임은 일종의 엔티티 및 부가정보에 대한 선언문이라고 생각하면 됩니다.클레임의 유형은 3가지가 있습니다.\nRegistered Claim\n필수는 아닙니다. 하지만 권장됩니다.\nClaim 들의 집합인데, 권장되는 Claim 들의 집합입니다. 필수는 아닙니다.\n안넣어도 되고, 엄청 중요한 것은 아닙니다.\ne.g. iss(issuer), exp(expiration time), sub(subject), aud(audience), 그 외 기타\nPublic Claim\nPrivate Claim\n개인이 필요할 때 만들어서 추가해서 넣을 수 있는 클레임입니다.\n사용자임을 식별할 수 있는 어떠한 primary key 같은 것들을 Primary Claim 에 넣는 경우가 많습니다.\n개인적으로 추가되는 정보임을 나타내는 정보\ne.g. \"user_id\" : 1\n핵심은 페이로드에 무엇을 넣는지입니다. 그 중 가장 중요한 것은 Private Claim (개인 클레임) 입니다. 예를 들면 이 개인 클레임(Private Claim)에는 user_id 나 primary_key 같은 식별 가능한 키를 암호화해서 넣는 편입니다.","signature-서명#Signature (서명)":"header, payload 와 secret(개인키, 일반적으로 서버에서 따로 보안된 위치에 따로 보관)를 HMAC 으로 암호화하는 것을 의미합니다. HS256 이라는 것은 HMAC SHA 256 이라는 알고리즘을 의미합니다.secret 이라는 것은 사용자가 지정한 임의의 문자열입니다.예를 들면 'abcdefghijklmnopqrstuvwxyz1234567' 같은 문자열을 팀에서 키를 조합할때 사용할 비밀키로 지정했을 때 이 'abcdefghijklmnopqrstuvwxyz1234567 라는 문자열과 header, payload 값을 HMACSHA256 함수에 인자로 해서 생성하면 서명된 문자열이 도출됩니다.이것을 서명이라고 이야기합니다.JWT 의 헤더는 아래와 같이 구성되는데 \"alg\" : \"HS256\" 이라는 것은 알고리즘으로 HMAC SHA 256 이라는 알고리즘을 사용하겠다는 것을 의미합니다.\n{\r\n    \"alg\": \"HS256\",\r\n    \"typ\": \"JWT\"\r\n}"}},"/":{"title":"Introduction","data":{"":"안녕하세요. 이 블로그는 Spring Webflux 기반의 Spring Security 관련된 예제와 개념, 문서를 정리하는 곳입니다. 간단한 JWT 인증을 ReactiveAuthenticationManager 를 이용해서 구현하는 것부터 시작해서 OAuth2 까지 정리해둘 예정입니다.이 외에도 Servlet 기반의 간단한 JWT 인증 예제 역시 정리해 둘 예정입니다."}},"/oauth2/Intro":{"title":"Intro","data":{}},"/jwt-basic/jwt-generate-degenerate-example":{"title":"JWT Generate Degenerate Example","data":{"jwt-생성-분해#JWT 생성, 분해":"이번 문서에서는 Java 기반으로 JWT 를 생성하고 분해하는 예제를 살펴봅니다.","의존성-추가#의존성 추가":"jjwt-api, jjwt-impl 등의 라이브러리는 github.com/jwtk/jjwt 에서 제공하는 라이브러리입니다.\ndependencies {\r\n    // ...    \r\n\timplementation 'io.jsonwebtoken:jjwt-api:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-impl:0.11.2'\r\n\timplementation 'io.jsonwebtoken:jjwt-jackson:0.11.2'\r\n    // ...\r\n}\nJava 기반의 JWT 라이브러리를 선택하는 것은 jwt.io/libraries?language=java 에서 확인 가능합니다. 저의 경우에는 io.jsonwebtoken 에서 제공하는 라이브러리를 선호하기 때문에 io.jsonwebtoken 계열의 라이브러리를 선택했습니다. 캡쳐에서 보이듯 지원되는 알고리즘이 많은 것을 확인 가능합니다. 하단의 View Repo 버튼을 클릭하면 Github Repository 로 이동합니다.\njwt.io/libraries?language=java 페이지에서 가장 최상단에 나타나는 라이브러리가 지원되는 알고리즘이 많은 것은 아닙니다. 예를 들어 가장 최상단에 나타난 com.auth0 에서 제공하는 JWT 라이브러리는 일부 알고리즘이 지원되지 않음을 확인 가능합니다. 꼭 지원되는 알고리즘을 확인하시고 라이브러리를 선택하시기를 바랍니다.","언어별로-지원되는-jwt-라이브러리-확인#언어별로 지원되는 JWT 라이브러리 확인":"jwt.io 에서는 Libraries 탭을 클릭하면 https://jwt.io/libraries 로 이동됩니다. 여기서 모든 언어에서 지원되는 JWT 라이브러리들이 리스팅 되어서 보여지고 Filter by 메뉴에서 원하는 언어를 클릭해서 원하는 언어에서 지원되는 JWT 공식 라이브러리들과 지원되는 알고리즘들을 확인하실 수 있습니다.","secret-정의-hs256-기반의-key-생성#Secret 정의, HS256 기반의 Key 생성":"Secret 으로 사용할 문자열을 정의하고 이 문자열을 HS256 기반의 알고리즘으로 Key 를 생성합니다.저의 경우는 SecurityProperties.java 라는 별도의 클래스에 Key, Secret 을 정의해두었습니다.\npublic class SecurityProperties {\r\n  public static final String SECRET = \"\";\r\n  public static final Key key = Keys.hmacShaKeyFor(SECRET.getBytes(StandardCharsets.UTF_8));\r\n}","jwt-생성-분해-1#JWT 생성, 분해":"JWT 생성, 분해를 하는 코드는 아래와 같습니다. 간단한 테스트 코드를 통해 확인해봅니다.\n// ...\r\n\r\npublic class JwtSupportTest {\r\n  // ...\r\n\r\n  @DisplayName(\"JWT_생성_분해_테스트\")\r\n  @Test\r\n  public void TEST_JWT_생성_분해_테스트(){\r\n    // (1)\r\n    // given\r\n    String username = \"John Deer\";\r\n    String userId = \"jdman\";\r\n    Key key = SecurityProperties.key;\r\n\r\n    // (2)\r\n    // when\r\n    // JWT 생성\r\n    String jwt = Jwts.builder()\r\n      .setSubject(username)\r\n      .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n      .claim(\"id\", userId)\r\n      .claim(\"username\", username)\r\n      .signWith(key, SignatureAlgorithm.HS256)\r\n      .compact();\r\n\r\n    // then\r\n    // JWT 분해\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(jwt);\r\n\r\n    assert claimsJws.getBody().get(\"id\", String.class).equals(userId);\r\n    assert claimsJws.getBody().get(\"username\", String.class).equals(username);\r\n  }\r\n  \r\n}\n(1)John Deer 라는 이름과 jdman 이라는 userId 에 대해서 Key를 기반으로 JWT를 생성합니다. JWT는 하나의 문자열 토큰입니다. Key 는 위에서 설명했듯 SecurityProperties 라는 클래스에서 특정 문자열 시크릿을 static 하게 HS256 기반의 알고리즘으로 생성해둔 Key 입니다.(2)JWT 문자열을 생성 시에는 Key 를 기반으로 서명을 생성합니다. 그리고 Jwt에 필수적으로 저장할 claim 들은 id 로 지정했습니다.\n(3)생성한 JWT 문자열에서 id, username 등과 같은 정보를 추출해냅니다.","컴포넌트로-정의#컴포넌트로 정의":"제 경우에는 위의 코드들을 하나의 컴포넌트로 생성했고, 스프링 컨테이너에서 객체를 생성해서 관리하도록 해두었습니다.\npackage io.chagchagchag.example.foobar.core.user.jwt;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jws;\r\nimport io.jsonwebtoken.JwtParser;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport org.springframework.http.server.reactive.ServerHttpResponse;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class JwtSupport {\r\n  public String generateToken(Key key, String userId, String username){\r\n    return Jwts.builder()\r\n        .setSubject(username)\r\n        .setExpiration(new Date(System.currentTimeMillis() + 864000000))\r\n        .claim(\"id\", userId)\r\n        .claim(\"username\", username)\r\n        .signWith(key, SignatureAlgorithm.HS256)\r\n        .compact();\r\n  }\r\n\r\n  public void addJwtAtResponseHeader(String jwt, ServerHttpResponse response){\r\n    response.getHeaders().add(\"Authorization\", String.format(\"Bearer %s\", jwt));\r\n  }\r\n\r\n  public JwtDto degenerateToken(Key key, String token){\r\n    JwtParser parser = Jwts.parserBuilder()\r\n        .setSigningKey(key)\r\n        .build();\r\n\r\n    Jws<Claims> claimsJws = parser.parseClaimsJws(token);\r\n\r\n    return new JwtDto(\r\n        claimsJws.getBody().get(\"id\", String.class),\r\n        claimsJws.getBody().get(\"username\", String.class),\r\n        claimsJws.getBody().getExpiration()\r\n    );\r\n  }\r\n\r\n  public Boolean checkContainsBearer(String header){\r\n    var len = \"Bearer \".length();\r\n    return header.substring(0, len).equalsIgnoreCase(\"Bearer\");\r\n  }\r\n\r\n  // 만료되면 true\r\n  // 만료되지 않았으면 false\r\n  public Boolean checkIfNotExpired(Date expiration){\r\n    return expiration.after(new Date());\r\n  }\r\n}"}},"/servlet-security-auth/intro":{"title":"Intro","data":{}}}